# design
## 软件设计原则
### 开闭原则 -- 对扩展开放，对修改关闭
### 里氏替换原则 -- 父类能出现的位置，子类必须可以出现  
### 依赖倒转原则 -- 去依赖抽象，不去依赖具体实现
### 接口隔离原则 -- 去除不需要的实现，最小粒度依赖
### 迪米特原则 -- 与无需直接通信的对象交互时，由第三方可依赖的对象转发
### 合成服用原则 -- 尽量使用组合与聚合关系，避免使用继承关系
## 23种设计模式代码示例
### 创建型模式
+ 工厂方法
+ 抽象工厂
+ 单例模式 
+ 原型模式（复制）
+ 建造者模式（内部类）
### 结构型模式
+ 适配器模式 
+ 代理模式  
  + 静态代理
  + 动态代理-jdk   接口
  + 动态代理-cglib 类
+ 适配器模式
  + 类适配器   继承实现
  + 对象适配器 组合聚合实现
+ 装饰者模式 继承并组合聚合 装饰者与被装饰者独立扩展 增加行为new对象
+ 桥接模式 抽象化角色聚合实现化角色，扩展抽象化角色配合具体实现化角色 例：OpratingSystem system = new Linux(new RmvbFile());
+ 外观模式 迪米特法则完美应用,不符合开闭原则,外观角色聚合子系统角色实现功能
+ 组合模式 树 tree,叶子节点继承抽象父级节点
+ 享元模式 抽象享元角色对象声明内部状态和外部状态，通过享元池共享现有对象减少创建对象数量
### 行为型模式
+ 模板方法模式 定义方法骨架，子类不改变结构情况下完成特定步骤
+ 策略模式 一系列可以相互替换的算法构成可供选择的策略,有聚合策略类对象的具体环境类
+ 命令模式 发出请求与执行请求分开，两者通过命令沟通,调用对象去调用命令对象，完成请求对象与执行对象的交互
+ 职责链模式 一个流程的多个处理者形成一条链，请求发生时沿链传递，直到被处理,具体处理者聚合下一个处理者对象的引用
+ 状态模式 代码运行时的不同状态,需要进行不同的处理,在状态对象中处理复杂逻辑,避免if语句！ 面向对象！
+ 观察者模式 发布订阅！一对多 Observable类
+ 中介者模式 又叫调停模式,中介角色给对象解耦,对象聚合中介角色,通过中介角色交互
+ 迭代器模式 遍历，引入了抽象层迭代器，简化聚合类设计（分担原聚合类中类方法）,提供中遍历方式,无需暴露聚合类内部细节
+ 访问者模式 在不改变数据结构的情况下,定义操作元素的方法！违反开闭原则,违反依赖倒置原则,对象结构稳定可以用
+ 备忘录模式 叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，需要时回滚！备份！
  + 黑箱模式 窄接口
  + 白箱模式 宽接口
+ 解析器模式 给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子！非终结表达式递归,终结表达式取值~~~~


